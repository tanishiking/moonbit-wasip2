// Generated by `wit-bindgen` 0.35.0. DO NOT EDIT!

pub enum StreamError {
      LastOperationFailed(@error.Error_)
      Closed
} derive(Show, Eq)

pub type InputStream Int derive(Show, Eq)

/// Drops a resource handle.
pub fn InputStream::drop(self : InputStream) -> Unit {
      let InputStream(resource) = self
      wasmImportResourceDropInputStream(resource)
}

pub type OutputStream Int derive(Show, Eq)

/// Drops a resource handle.
pub fn OutputStream::drop(self : OutputStream) -> Unit {
      let OutputStream(resource) = self
      wasmImportResourceDropOutputStream(resource)
}

pub fn InputStream::read(self : InputStream, len : UInt64) -> Result[Bytes, StreamError] {

      let InputStream(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodInputStreamRead(handle, (len).reinterpret_as_int64(), return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2bytes(@ffi.load32((return_area) + 4))

                  Result::Ok(result)
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 8)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn InputStream::blocking_read(self : InputStream, len : UInt64) -> Result[Bytes, StreamError] {

      let InputStream(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodInputStreamBlockingRead(handle, (len).reinterpret_as_int64(), return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2bytes(@ffi.load32((return_area) + 4))

                  Result::Ok(result)
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 8)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn InputStream::skip(self : InputStream, len : UInt64) -> Result[UInt64, StreamError] {

      let InputStream(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodInputStreamSkip(handle, (len).reinterpret_as_int64(), return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 8)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 12)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn InputStream::blocking_skip(self : InputStream, len : UInt64) -> Result[UInt64, StreamError] {

      let InputStream(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodInputStreamBlockingSkip(handle, (len).reinterpret_as_int64(), return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 8)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 12)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn InputStream::subscribe(self : InputStream) -> @poll.Pollable {

      let InputStream(handle) = self
      let result : Int =  wasmImportMethodInputStreamSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn OutputStream::check_write(self : OutputStream) -> Result[UInt64, StreamError] {

      let OutputStream(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodOutputStreamCheckWrite(handle, return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 8)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 12)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn OutputStream::write(self : OutputStream, contents : Bytes) -> Result[Unit, StreamError] {

      let OutputStream(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodOutputStreamWrite(handle, @ffi.bytes2ptr(contents), contents.length(), return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 8)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      ignore(contents)
      @ffi.free(return_area)
      return lifted6

}

pub fn OutputStream::blocking_write_and_flush(self : OutputStream, contents : Bytes) -> Result[Unit, StreamError] {

      let OutputStream(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodOutputStreamBlockingWriteAndFlush(handle, @ffi.bytes2ptr(contents), contents.length(), return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 8)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      ignore(contents)
      @ffi.free(return_area)
      return lifted6

}

pub fn OutputStream::flush(self : OutputStream) -> Result[Unit, StreamError] {

      let OutputStream(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodOutputStreamFlush(handle, return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 8)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn OutputStream::blocking_flush(self : OutputStream) -> Result[Unit, StreamError] {

      let OutputStream(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodOutputStreamBlockingFlush(handle, return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 8)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn OutputStream::subscribe(self : OutputStream) -> @poll.Pollable {

      let OutputStream(handle) = self
      let result : Int =  wasmImportMethodOutputStreamSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn OutputStream::write_zeroes(self : OutputStream, len : UInt64) -> Result[Unit, StreamError] {

      let OutputStream(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodOutputStreamWriteZeroes(handle, (len).reinterpret_as_int64(), return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 8)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn OutputStream::blocking_write_zeroes_and_flush(self : OutputStream, len : UInt64) -> Result[Unit, StreamError] {

      let OutputStream(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodOutputStreamBlockingWriteZeroesAndFlush(handle, (len).reinterpret_as_int64(), return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 8)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn OutputStream::splice(self : OutputStream, src : InputStream, len : UInt64) -> Result[UInt64, StreamError] {

      let OutputStream(handle) = self

      let InputStream(handle0) = src
      let return_area = @ffi.malloc(16)
      wasmImportMethodOutputStreamSplice(handle, handle0, (len).reinterpret_as_int64(), return_area);

      let lifted7 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 8)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 12)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted7

}

pub fn OutputStream::blocking_splice(self : OutputStream, src : InputStream, len : UInt64) -> Result[UInt64, StreamError] {

      let OutputStream(handle) = self

      let InputStream(handle0) = src
      let return_area = @ffi.malloc(16)
      wasmImportMethodOutputStreamBlockingSplice(handle, handle0, (len).reinterpret_as_int64(), return_area);

      let lifted7 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 8)) {
                        0 => {

                              StreamError::LastOperationFailed(@error.Error_::Error_(@ffi.load32((return_area) + 12)))
                        }
                        1 => {

                              StreamError::Closed
                        }
                        _ => panic()
                  }

                  Result::Err(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted7

}

